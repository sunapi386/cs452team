#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{lastpage}
\usepackage[ddmmyyyy]{datetime}

\fancyhf{} % clear existing head/footers
\fancyhead[L]{CS 452 Train Control 1}
\fancyhead[C]{WatOS}
\fancyhead[R]{j53sun \& s34chang}

\fancyfoot[L]{\fontsize{8}{8} \today: \currenttime}
\fancyfoot[R]{\fontsize{8}{8} \thepage\ / \pageref{LastPage}}

\makeatletter
\let\ps@plain\ps@fancy   % Plain page style = fancy page style
\makeatother
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CS 452: Train Control Part 2
\end_layout

\begin_layout Author
Jason Sun (#20387090) and Shuo Chang (#20378235)
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part
Administrative Details
\end_layout

\begin_layout Section
Source Code Location
\end_layout

\begin_layout Itemize
Repository location is 
\family typewriter
gitlab@git.uwaterloo.ca:j53sun/cs452team.git
\end_layout

\begin_layout Itemize
Checkout by label: 
\family typewriter
tc2
\end_layout

\begin_layout Itemize
Or, checkout by SHA1 hash: 
\end_layout

\begin_layout Itemize
Compiling by running
\family typewriter
 make tc2
\end_layout

\begin_layout Subsection
List of Submitted Files
\end_layout

\begin_layout Standard
See git commit at hash.
\end_layout

\begin_layout Section
Program Operation
\end_layout

\begin_layout LyX-Code
\align block
> load -b 0x00200000 -h 129.97.167.12 "ARM/sunchang/tc2.elf"
\end_layout

\begin_layout LyX-Code
> go
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="2">
<features rotate="0" booktabs="true" tabularvalignment="middle">
<column alignment="left" valignment="top" width="5cm">
<column alignment="left" valignment="top" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Command
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Action
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
tr train_num speed
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
set train speed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
rv train_num
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
reverse train
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
sw train_num direction
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
switch a turnout 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
e train_num speed
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
create engineer for train and give speed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
h train_num sensor_char sensor_num
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
halt on sensor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
m sensor1_char sensor1_num sensor2_char sensor2_num
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
display timing from sensor1 to sensor2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
g
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
go at previous train, speed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stop previous train
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
c train_number speed sensor_group sensor_num num_loops
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calibration mode: stop at sensor and delay, then repeat
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
k track_A_or_B
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load track A or B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
x nodeIndex offset
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Stop the train at offset millimeters before that node
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
q
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Quit
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
o
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Print turnouts again
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
p
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Print track drawing again
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
d
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Debug printout of active tasks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
?
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prints out help message
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Part
Kernel Structure Details
\end_layout

\begin_layout Section
Stack Layout
\end_layout

\begin_layout Standard
When the user does a syscall, the top of the user stack to store userâ€™s
 current registers.
 The layout of registers stored is: 
\end_layout

\begin_layout LyX-Code
[ R1 (PC)   ] <-- SP after storing trap frame
\end_layout

\begin_layout LyX-Code
[ R2 (CSPR) ]
\end_layout

\begin_layout LyX-Code
[   ...
     ]
\end_layout

\begin_layout LyX-Code
[ R12       ]
\end_layout

\begin_layout LyX-Code
[ LR        ]
\end_layout

\begin_layout LyX-Code
[   ...
     ] <-- SP at SWI instruction
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Initializing the trap frame for the first time is done in 
\family typewriter
taskCreate()
\family default
, and for later context context switches, the trap frame is handled in 
\family typewriter
context_switch.s
\family default
, written in assembly code.
 On return, the result of the syscall is stored in 
\family typewriter
r0
\family default
, and execution resumes at function 
\family typewriter
swi()
\family default
, where the syscall occurred.
\end_layout

\begin_layout Section
Syscalls
\end_layout

\begin_layout Standard
Syscalls defined in C functions, in
\family typewriter
 syscall.{c,h}
\family default
 files.
 There is a
\family typewriter
 Syscall
\family default
 structure that contains the syscall type, and args 1 and args 2.
\end_layout

\begin_layout Itemize

\family typewriter
int
\begin_inset space ~
\end_inset

Create(int
\begin_inset space ~
\end_inset

priority,
\begin_inset space ~
\end_inset

void
\begin_inset space ~
\end_inset

(*code)())
\family default
 Schedule a task with specified
\family typewriter
 priority
\family default
 and function pointer
\family typewriter
 code
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
int
\begin_inset space ~
\end_inset

MyTid()
\family default
 Return the task id for the calling task.
\end_layout

\begin_layout Itemize

\family typewriter
int
\begin_inset space ~
\end_inset

MyParentTid()
\family default
 Return the task id of the parent of the calling task.
\end_layout

\begin_layout Itemize

\family typewriter
void
\begin_inset space ~
\end_inset

Pass()
\family default
 No-op for entering the kernel.
\end_layout

\begin_layout Itemize

\family typewriter
void
\begin_inset space ~
\end_inset

Exit()
\family default
 Exits the calling task and never schedule it again.
\end_layout

\begin_layout Itemize

\family typewriter
int Send( int tid, void *msg, int msglen, void *reply, int replylen )
\end_layout

\begin_layout Itemize

\family typewriter
int Receive( int *tid, void *msg, int msglen )
\end_layout

\begin_layout Itemize

\family typewriter
int Reply( int tid, void *reply, int replylen )
\end_layout

\begin_layout Standard
Added 
\family typewriter
arg3, arg4, arg5
\family default
 to Syscall data structure to support a maximum of 5 system call arguments.
\end_layout

\begin_layout Section
Tasks
\end_layout

\begin_layout Standard
A task can be created off a function pointer and represents a chunk of code
 to execute.
\end_layout

\begin_layout Subsection
Task Descriptor
\end_layout

\begin_layout Standard
The kernel's TaskDescriptor:
\end_layout

\begin_layout LyX-Code
typedef struct TaskDescriptor {
\end_layout

\begin_layout LyX-Code
    int id;
\end_layout

\begin_layout LyX-Code
    int parent_id;
\end_layout

\begin_layout LyX-Code
    int ret;
\end_layout

\begin_layout LyX-Code
    unsigned int *sp;
\end_layout

\begin_layout LyX-Code
    Status status;
\end_layout

\begin_layout LyX-Code
    int *send_id;
\end_layout

\begin_layout LyX-Code
    void *send_buf, *recv_buf;
\end_layout

\begin_layout LyX-Code
    unsigned int send_len, recv_len;
\end_layout

\begin_layout LyX-Code
    struct TaskDescriptor *next; 
\end_layout

\begin_layout LyX-Code
} TaskDescriptor;
\end_layout

\begin_layout Standard
Where a Status is
\end_layout

\begin_layout LyX-Code
typedef enum {
\end_layout

\begin_layout LyX-Code
    ready,         
\end_layout

\begin_layout LyX-Code
    send_blocked,  
\end_layout

\begin_layout LyX-Code
    receive_block, 
\end_layout

\begin_layout LyX-Code
    reply_block,   
\end_layout

\begin_layout LyX-Code
} Status;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Paragraph
Descriptor Notes
\end_layout

\begin_layout Itemize
Task id contains an index into a global table of task descriptors pre-allocated
 
\end_layout

\begin_layout Itemize
The 
\family typewriter
spsr
\family default
 is manipulated by context switch code
\end_layout

\begin_layout Itemize
Not all 7 task status are needed
\end_layout

\begin_layout Itemize
The 
\family typewriter
send_id,
\family default
 
\family typewriter
send_buf, send_len, recv_buf, recv_len 
\family default
are for IPC.
\end_layout

\begin_layout Subsection
Task Creation
\end_layout

\begin_layout Standard
A task is created by specifying a priority, a function pointer, and parent
 task id.
 The
\family typewriter
 Create()
\family default
 syscall is implemented by this function.
\end_layout

\begin_layout Standard
A task descriptor is filled in to the task table.
 Then a stack is allocated, a size of 4096 words.
 There is syscall to change a task's stack size.
 It also initializes a trap frame by setting
\family typewriter
pc
\family default
 to the value of the function pointer and saved stored program register.
 Currently only can create 128 tasks before failing to create more tasks.
\end_layout

\begin_layout Standard
Finally the kernel adds the task descriptor to priority queue.
\end_layout

\begin_layout Subsection
Task Scheduling
\end_layout

\begin_layout Standard
Tasks each has a priority level.
 The scheduler tracks this tasks' priority via 32 ring buffer queues.
\end_layout

\begin_layout Standard
A bitmask keeps track of which of the 32 queues contains tasks.
 Using this bitmask, we efficiently computing the number of right leading
 zeroes in the bitmask with De Bruijn table lookup.
\end_layout

\begin_layout Standard
The kernel calls
\family typewriter
taskSchedule()
\family default
 on each loop, and the queue with the highest priority is returned.
 The head of that queue is rotated to be the tail and the pointer is returned
 as the next task to be scheduled.
\end_layout

\begin_layout Subsection
Task Communication
\end_layout

\begin_layout Standard
Tasks who are able to make a system call are not in any queues.
 
\end_layout

\begin_layout Standard
There are three handlers for 
\family typewriter
Send()
\family default
, 
\family typewriter
Receive()
\family default
, and 
\family typewriter
Reply()
\family default
 system calls, and sets the appropriate values.
 
\end_layout

\begin_layout Enumerate

\family typewriter
handleSend()
\family default
 checks whether the intended receiver is currently receive blocked.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
If receiver's status is in receive block, then copy the buffer from sender
 to receiver directly, and set it's status to reply blocked.
\end_layout

\begin_layout Enumerate
Else, enqueue to the receiver's send queue then update it's status to send
 blocked.
 
\end_layout

\begin_layout Enumerate
It also copies sender's reply buffer and reply buffer length into recv_buf,
 recv_len in sender's task descriptor for later use in 
\family typewriter
handleReply()
\family default
.
\end_layout

\end_deeper
\begin_layout Enumerate

\family typewriter
handleReceive()
\family default
 checks whether there are senders in receiver's send queue.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
If there exists senders, then dequeue sender and move the message.
 Sender's status is set to reply blocked, and move the receiver to the ready
 queue.
 
\end_layout

\begin_layout Enumerate
If there are no queued senders, set receiver's status to receive blocked.
 Store the pointer to the buffer and length to the receiver's task descriptor.
\end_layout

\end_deeper
\begin_layout Enumerate

\family typewriter
handleReply()
\family default
 copies the message from the receiver to the sender.
 The sender's reply buffer address is tracked in its task descriptor, put
 there by 
\family typewriter
handleSend()
\family default
.
\end_layout

\begin_layout Paragraph
Memcpy
\end_layout

\begin_layout Standard
The 
\family typewriter
memcpy()
\family default
 is implmented in assembly to make message passing faster.
 Four registers are used, along with multiple load and unload assembly instructi
on.
 To deal with non-padded copying, the extra bits are copied by jumping into
 an unrolled loop 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Duff's Device http://en.wikipedia.org/wiki/Duff%27s_device
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Task Exit
\end_layout

\begin_layout Standard
Once a task is removed from the priority queues, the task will not be scheduled
 again.
 No effort is made to reclaim task descriptors.
\end_layout

\begin_layout Section
Handling Interrupts
\end_layout

\begin_layout Standard
Before Kernel 3, software interrupts are triggered using 
\family typewriter
swi
\family default
 via system calls, and IRQ is disabled in user mode.
 The context switch of the kernel made assumptions regarding the registers
 on kernel entry.
 Specifically, 
\family typewriter
r0
\family default
 was thought to contain a fixed pointer to the address of the static request
 struct, and thus was not saved and restored during the context switch.
 Furthermore, registers 
\family typewriter
r2
\family default
 and 
\family typewriter
r3
\family default
 are dedicated to store/load user 
\family typewriter
pc
\family default
 and user 
\family typewriter
cpsr
\family default
.
 The solution worked at the time because the GCC handled saving/restoring
 of scratch registers in system call stubs.
\end_layout

\begin_layout Standard
By enabling hardware interrupt in Kernel 3, these assumptions are no longer
 true: in addition to the new IRQ mode introduced by hardware interrupt,
 interrupts can occur any stage of the user program execution.
 Scratch registers must be properly saved in order for the kernel to function
 correctly.
 The following lists will describe how the new context switch code work:
\end_layout

\begin_layout Subsection
Kernel Exit
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top" width="6cm">
<column alignment="left" valignment="top" width="8cm">
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assembly
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Explaination
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
stmfd sp!, {r0-r12, lr}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Store all kernel registers onto kernel stack
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xdf
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change to system mode 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ldr sp, [r0, #12]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load task sp into sp 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ldr r0, [r0, #8]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load task return value into r0 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
mov r1, sp
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load sp into r1 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
add sp, sp, #8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Update sp to after popping user cpsr, pc 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xd3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change back to supervisor mode
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ldmfd r1, {r2, lr}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load user cpsr and user pc to supervisor lr 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr spsr, r2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load user cpsr to supervisor's spsr 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xdf
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change to system mode 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ldmfd sp!, {r1-r12, lr}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load user registers from user stack 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xd3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change to supervisor mode 
\end_layout

\end_inset
</cell>
</row>
<row topspace="default">
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
movs pc, lr 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Execute user code 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Hardware Interrupt Enter
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top" width="6cm">
<column alignment="left" valignment="top" width="8cm">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assembly
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Explaination
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xd3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Go to supervisor mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
stmfd sp!, {r0}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Push r0 on the kernel stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xd2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Go to irq mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
sub r0, lr, #4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Put lr - 4 (pc_usr) to r0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xd3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Go to supervisor mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
mov lr, r0
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Put correct user pc to supervisor lr
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ldmfd sp!, {r0}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Restore r0 from the kernel stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr spsr_c, #0x50
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Set spsr to user mode (irq enabled)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph

\shape italic
\emph on
Note 
\end_layout

\begin_layout Standard

\shape italic
\emph on
The program counter automatically advances into kernelEnter after the last
 instruction in this routine.
\end_layout

\begin_layout Subsection
Kernel Enter
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top" width="6cm">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Assembly
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Explaination
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xdf
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change to system mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
stmfd sp!, {r1-r12, lr}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Store all user registers to user stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
mov r1, sp
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Put user sp in r1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
sub sp, sp, #8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Calculate user sp after pushing cpsr and pc
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
mrs r2, sps3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Put spsr (user cpsr) in r2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
msr cpsr_c, #0xd3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change back to supervisor mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
stmfd r1!, {r2, lr}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Store r2 (user cpsr), lr (user pc) to user stack
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ldmfd sp!, {r0}
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load r0 (*task)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str r1, [r0, #12]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Store r1 (user sp) in task->sp
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
str r0, [r0, #8]
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Store r0 in task->ret
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
ldmfd sp!, {r1-r12, pc} 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load the rest of the kernel registers from stack
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
AwaitEvent
\end_layout

\begin_layout Standard
Description of int 
\family typewriter
AwaitEvent(int eventType)
\family default
.
 A table of 64 task descriptor pointers keeps track which task is registered
 to await a given interrupt.
\end_layout

\begin_layout Itemize
When AwaitEvent is called, it adds the calling task into the table and sets
 the enable bit for that interrupt code.
\end_layout

\begin_layout Itemize
At most one task to block on a single event.
 Although if needed, multiple tasks can be changed up through the next field
 in the task descriptor if needed.
\end_layout

\begin_layout Itemize
If the event is related to IO, then the interrupt is set to enabled.
\end_layout

\begin_layout Section
Hardware Interrupt Handler
\end_layout

\begin_layout Standard
The interrupt handler handles 6 interrupts (listed in order of handling
 priority): 
\end_layout

\begin_layout Itemize
Timer 3 underflow interrupt
\end_layout

\begin_layout Itemize
UART 1 modem interrupt
\end_layout

\begin_layout Itemize
UART 1 transmit interrupt
\end_layout

\begin_layout Itemize
UART 1 receive interrupt
\end_layout

\begin_layout Itemize
UART 2 receive interrupt
\end_layout

\begin_layout Itemize
UART 2 transmit interrupt
\end_layout

\begin_layout Standard
When an interrupt occurs, the highest priority interrupt is handled.
 Only one interrupt is handled per kernel entry.
 If the interrupt is related to UARTs, then the interrupt is disabled in
 the UART.
 Furthermore, the handling of UART 1 transmit event is slightly different
 than the other interrupts; the waiting task is only unblocked when the
 kernel handles a transmit interrupt as well as a modem interrupt where
 both the CTS bit and the DCTS bit are asserted.
\end_layout

\begin_layout Part
Core Servers
\end_layout

\begin_layout Section
Nameserver
\end_layout

\begin_layout Standard
The nameserver should be created during kernel initialization by the first
 user task, such that its task id is entirely deterministic, and is be shared
 as a constant between tasks (for those tasks that do not use the syscall).
 Calls supported are:
\end_layout

\begin_layout LyX-Code
int RegisterAs(char *name)
\end_layout

\begin_layout LyX-Code
int WhoIs(char *name)
\end_layout

\begin_layout Standard
The nameserver keeps track of tasks in a 
\family typewriter
{name, task_id entry}
\family default
, in table.
 The table has a static size of 256.
 Insertion, and lookup, scans the entire table.
 
\end_layout

\begin_layout Standard
Linear scan is used instead of something with better performance because
 the nameserver is anticipated not to be called after a task initializes,
 therefore its performance is not important.
\end_layout

\begin_layout Section
Clock Server
\end_layout

\begin_layout Standard
The clock server, together with the notifier, provides timing functionality
 for other user programs.
 Three functions are provided: 
\end_layout

\begin_layout Enumerate

\family typewriter
Time()
\family default
 returns the current system tick; a tick is defined to be 10 ms.
\end_layout

\begin_layout Enumerate

\family typewriter
Delay()
\family default
 delays a task for certain number of ticks; and 
\end_layout

\begin_layout Enumerate

\family typewriter
DelayUntil()
\family default
 delays a task till a certain time.
 
\end_layout

\begin_layout Standard
These functions wrap 
\family typewriter
Send()
\family default
 to the clock server; therefore, their only difference is the type of request
 they send.
 A 
\family typewriter
ClockReq
\family default
 struct, composing of a request type and request data, is passed around
 the clock server, the clock notifier, and client tasks, to communicate
 requests.
\end_layout

\begin_layout LyX-Code
typedef struct ClockReq {
\end_layout

\begin_deeper
\begin_layout LyX-Code
int type;
\end_layout

\begin_layout LyX-Code
int data;
\end_layout

\end_deeper
\begin_layout LyX-Code
} ClockReq;
\end_layout

\begin_layout Standard
The wrapper functions also loop up the clock server on the name server,
 and set it to a static variable declared within each function.
 It is build using the message passing mechanisms.
 It also registers with the nameserver so it could be discovered by other
 tasks.
 
\end_layout

\begin_layout Standard
The clock server keeps track of requests through a clock notifier.
\end_layout

\begin_layout Subsection
Clock Notifier
\end_layout

\begin_layout Standard
The clock notifier waits for a timer interrupt to occur using the kernel
 primitive 
\family typewriter
AwaitEvent()
\family default
 and uses timer 3 underflow interrupt.
 On interrupt, it gets unblocked by the kernel and sends a notification
 to the clock server, signaling it to increase current tick.
 
\end_layout

\begin_layout Subsection
Delayed Task
\end_layout

\begin_layout Standard
This struct is used by the clock server to keep track of tasks blocked by
 
\family typewriter
Delay()
\family default
 and 
\family typewriter
DelayUntil()
\family default
.
 The tid is the tid of the task, the finalTick is the time that the delay
 expires; the next pointer is to support inserting/removing into DelayedQueue,
 a singly circular linked-list.
\end_layout

\begin_layout LyX-Code
typedef struct DelayedTask {
\end_layout

\begin_deeper
\begin_layout LyX-Code
int tid;
\end_layout

\begin_layout LyX-Code
unsigned int finalTick;
\end_layout

\begin_layout LyX-Code
struct DelayedTask *next;
\end_layout

\end_deeper
\begin_layout LyX-Code
} DelayedTask;
\end_layout

\begin_layout Subsection
Timer and Interrupt Control Units
\end_layout

\begin_layout Standard
The timer 3 in the EP9302 SoC is used to track time.
 It is set up to use 508 kHz clock in periodic mode, with load register
 set to 5080 (10 milliseconds interval between interrupts).
\end_layout

\begin_layout Standard
The SoC contains 2 PL190 interrupt controllers.
 On kernel start, the 20th bit (1<<19), of the second interrupt controller,
 which is the bit corresponds to timer interrupt, is enabled.
 Both interrupt control units' select bits are set to 0, which enables IRQ
 mode.
 When the program is about to exit, the 20th bit of the second interrupt
 controller is cleared.
\end_layout

\begin_layout Section
Interrupt Driven I/O
\end_layout

\begin_layout Standard
There are kinds of 4 servers and 4 notifiers: 
\end_layout

\begin_layout Itemize
Monitor-in server/notifier, handling input from the keyboard.
\end_layout

\begin_layout Itemize
Monitor-out server/notifier, for sending to the terminal.
\end_layout

\begin_layout Itemize
Train-in server/notifier, handling input from the train control unit.
\end_layout

\begin_layout Itemize
Train-out server/notifier, for sending to the train control unit.
\end_layout

\begin_layout Standard
This seperation is necessary because there are different interrupts that
 need to be handled, and it is conceptually easier to program them seperately
 despite the input servers being similar and output servers being similar.
\end_layout

\begin_layout Standard
Notifiers do similar tasks, which we will cover.
\end_layout

\begin_layout Subsection
Servers
\end_layout

\begin_layout Standard
On startup the server is responsible for creating its own notifier.
 The server is almost always receive blocked, waiting on the notifier.
 However, servers are responsible for dealing with interrupts and handling
 (somewhat complicated) interrupt procedures.
 We want the notifiers, which are the interrupt handlers, to return to waiting
 for interrupts as quickly as possible.
\end_layout

\begin_layout Subsubsection
Send Data
\end_layout

\begin_layout Standard
Data can be accepted as a string, using 
\family typewriter
PutString(struct String*) or PutStr(char*)
\family default
, and put into a send buffer.
 Or it can be accepted as a character at a time.
 Sending data only accepts a string to guarantee entire command is put into
 the send buffer atomically.
 This is to avoid interleaving commands from two different tasks, if we
 were to provide a single character sending command such as 
\family typewriter
Putc(char)
\family default
.
 
\end_layout

\begin_layout Standard
The server then provides data to the notifier from its send buffer when
 it checks in.
\end_layout

\begin_layout Subsubsection
Receive Data
\end_layout

\begin_layout Standard
The receive server gets data from a notifier event.
 It buffers that data and replies to the appropriate task.
 There is only 
\family typewriter
Getc()
\family default
 supported.
\end_layout

\begin_layout Subsection
Notifiers
\end_layout

\begin_layout Standard
Notifiers are very simple, they wait for input interrupts by calling AwaitEvent(
).
 When AwaitEvent() unblocks, it the notifier returns the volatile data back
 to the server.
\end_layout

\begin_layout Part
User Tasks
\end_layout

\begin_layout Section
Input Parsing
\end_layout

\begin_layout Standard
Parsing takes place after a complete string has been read in, meaning the
 user has pressed the return key.
 Then each character is fed into a parser.
 The parser is a finite state machine, and transitions the state upon acceptable
 valid.
 Upon unacceptable input the machine goes into Error state and all subsequent
 characters are colored red.
 For valid instruction, it calls the appropriate functions.
 
\end_layout

\begin_layout Standard
Quitting calls the syscall 
\family typewriter
Halt()
\family default
, which breaks out of the main loop of the kernel.
 Essentially it dumps all the active tasks on the floor.
\end_layout

\begin_layout Section
Clock Drawer
\end_layout

\begin_layout Standard
Calls 
\family typewriter
Time()
\family default
 and goes into an infinite loop that:
\end_layout

\begin_layout Enumerate
Prints time.
\end_layout

\begin_layout Enumerate
Increment time by 10 clicks (1 ms).
\end_layout

\begin_layout Enumerate
Calls 
\family typewriter
DelayUntil
\family default
.
\end_layout

\begin_layout Standard
DelayUntil is used instead of Delay to avoid clock slew, because the clockserver
 calls Time() each time we use Delay.
 Calculating the DelayUntil time ourselves therefore eliminates clock slewing.
\end_layout

\begin_layout Part
Train Control and Related Tasks
\end_layout

\begin_layout Section
Sensor Update
\end_layout

\begin_layout Standard
The sensor updates from the track is received by the trainOutServer.
 It is polled by the sensorWorker task by calling Getc(COM1), time-stamped
 by calling Time(), displayed onto the screen, then delivered to the sensor
 server.
 The sensor server then stores them into a buffer; the sensorCourier then
 calls Send() to the sensor server, which is replied with data from the
 buffer.
\end_layout

\begin_layout Standard
All sensor updates are attributed to the same engineer task as we only support
 one train at this moment.
\end_layout

\begin_layout Subsection
Sensor Worker
\end_layout

\begin_layout Standard
The sensor worker is created by the sensor server.
 On start, the sensor worker calls Putc(COM1, 133) to request for sensor
 data for all sensors.
 It then receives 10 bytes of sensor data.
 When the first of the 10 bytes is received, the courier calls Time(), which
 is used as the timestamp for all 10 sensor updates.
 On receiving each byte, the sensor worker prints out the triggered sensors
 onto the screen.
 For each byte, the sensor worker then sends to the sensor server with both
 the sensor and the timestamp.
\end_layout

\begin_layout Standard
To prevent stuck sensor from repeatedly being triggered, the courier saves
 each byte it receives in an character array of size 10.
 When a 0 byte is received by the courier, it sets the stored state to 0;
 else, the sensor worker AND the byte with the NEGATION of the stored byte.
 The result is printed and delivered only when the AND result is non-zero.
\end_layout

\begin_layout Subsection
Sensor Server
\end_layout

\begin_layout Standard
The sensor server receives from both the sensor courier and and the sensor
 worker.
 The sensor worker moves sensor updates from the COM1 output server to the
 sensor server; the sensor courier moves sensor updates from the buffer
 of sensor server to the engineer task.
\end_layout

\begin_layout Section
Train Control
\end_layout

\begin_layout Standard
There is one controller for many trains.
 At the moment there is just one train control supported so we have one
 engineer and no controller.
\end_layout

\begin_layout Subsection
Track Data Structure
\end_layout

\begin_layout Standard
The provided track data structure is used.
 On start of the kernel, the user could load either track A or track B using
 the k {a|b} command.
\end_layout

\begin_layout Subsection
Track Controller
\end_layout

\begin_layout Standard
Not implemented in TC1.
 The train controller will manage track reservation.
\end_layout

\begin_layout Subsection
Engineer
\end_layout

\begin_layout Standard
A train engineer is the task that calculates information such as displacement
 and velocity of a train.
 It is a server which receives from the LocationWorker, CommandWorker, SensorCou
rier, and the parser.
 Associated with the Engineer are data such as: 
\end_layout

\begin_layout Itemize
State
\end_layout

\begin_deeper
\begin_layout Itemize
Init: the initial state when the engineer is created.
\end_layout

\begin_layout Itemize
Stopped: when the train has been given speed 0, and has finished 
\begin_inset Quotes eld
\end_inset

Decelerating
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Running: when the train is running in constant velocity
\end_layout

\begin_layout Itemize
Reversing: when the train has came to a complete stop, and just issued a
 reverse command
\end_layout

\begin_layout Itemize
Decelerating: when the train is going in constant velocity, and the command
 of setting speed to 0 is executed
\end_layout

\begin_layout Itemize
Accelerating: when the speed is transitioning from 0 to a value that is
 greater than 0
\end_layout

\end_deeper
\begin_layout Itemize
Position and displacement
\end_layout

\begin_deeper
\begin_layout Itemize
Direction of the train, which forward is defined as the pick up being at
 the front of the train
\end_layout

\begin_layout Itemize
Previous sensor node
\end_layout

\begin_layout Itemize
Next sensor node
\end_layout

\begin_layout Itemize
Previous track node
\end_layout

\begin_layout Itemize
Next track node
\end_layout

\begin_layout Itemize
Distance after the previous track node
\end_layout

\end_deeper
\begin_layout Itemize
Speed (from 0 to 14)
\end_layout

\begin_layout Itemize
Velocity
\end_layout

\begin_layout Itemize
Timestamps for the previous sensor update
\end_layout

\begin_layout Itemize
A buffer of queued commands
\end_layout

\begin_layout Subsubsection
Update And Display Of Location Information
\end_layout

\begin_layout Standard
The display of location information is managed by both the engineer and
 the LocationWorker.
 The LocationWorker is a worker task created by the Engineer that calls
 Send() to the engineer with an 
\begin_inset Quotes eld
\end_inset

update_location
\begin_inset Quotes erd
\end_inset

 request to the 5 ticks.
 After the engineer process the request, it is replied with data to be printed
 onto the screen.
 Upon being unblocked, it then prints out the replied data to COM2 output
 server via a printf() call.
\end_layout

\begin_layout Standard
On receiving an 
\begin_inset Quotes eld
\end_inset

update_location
\begin_inset Quotes erd
\end_inset

 request, the engineer computes it's velocity based on the current state
 of the train.
 For example, if the state is 
\begin_inset Quotes eld
\end_inset

Decelerating
\begin_inset Quotes erd
\end_inset

, then the acceleration estimation of the train is computed, and velocity
 is decreased until zero; otherwise, if the state of the train is anything
 other than 
\begin_inset Quotes eld
\end_inset

Stopped
\begin_inset Quotes erd
\end_inset

, the velocity is computed by 
\family typewriter
(distance between previous and next sensor) / (calibrated time between the
 previous and next sensor)
\family default
.
 If the current train state is 
\begin_inset Quotes eld
\end_inset

Reversing
\begin_inset Quotes erd
\end_inset

, the previous and the next node, as well as the previous and the next sensor
 nodes recorded by the engineer, are swapped.
\end_layout

\begin_layout Standard
With velocity calculated, the task then could compute how far it's gone
 over previous track node, and the remaining distance to the next track
 node.
 If the remaining distance is equal to or smaller than 0 and that the next
 node is not a sensor node, then the current node and the next node is updated
 and replied to the LocationWorker.
 If the engineer has yet to reach the next node, the LocationWorker is replied
 with the updated distance to next node.
\end_layout

\begin_layout Standard
If the next node is a sensor and the distance to the sensor node is smaller
 or equal to zero, a negative distance is outputed.
 This is done because we only reach a sensor when the engineer receives
 a sensor update.
\end_layout

\begin_layout Subsubsection
Linear Deceleration
\end_layout

\begin_layout Standard
The deceleration is computed using the following formula:
\end_layout

\begin_layout Standard
\begin_inset Formula $accel=-v_{i}*v_{i}/(2*stoppingDistance)$
\end_inset


\end_layout

\begin_layout Standard
When the train enters into the 
\begin_inset Quotes eld
\end_inset

Decelerating
\begin_inset Quotes erd
\end_inset

 state, this acceleration value is computed once, and the velocity is decremente
d according to the deceleration until it reaches zero, then the state of
 the train is set to 
\begin_inset Quotes eld
\end_inset

Stopped
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsubsection
Sensor Update
\end_layout

\begin_layout Standard
The engineer task notified of sensor update via the sensorCourier, with
 the other end being the sensorServer.
 The sensorCourier first calls Send() to the sensorServer, and when the
 sensor server receives an update, the sensorCourier is replied with the
 sensor node index and a timestamp.
 The courier then call Send() to the engineer task with the exact data.
\end_layout

\begin_layout Standard
When a sensor update is delivered to the engineer, the engineer knows that
 a sensor has been triggered.
 The sensor updates the timeDeltas table that stores time differences between
 pairs of sensors, updates the previous landmark, next landmark, distance
 to next landmark, previous sensor (which is the sensor in this sensor update),
 current velocity (
\family typewriter
length of segment between previous & next sensor / time since last sensor
\family default
), expected time (which is looked up from timeDeltas table), the actual
 time (which is the timestamp of the sensor update), and error (
\family typewriter
abs(actual time - expected time)
\family default
).
\end_layout

\begin_layout Subsubsection
Execution Of Train Commands And Command Notifications
\end_layout

\begin_layout Standard
Previously, the execution of train commands are directly sent to the COM1
 input server by the parser.
 The downside of this solution is that it is not scalable for multiple trains,
 since reverse require two Delay() calls.
 Another problem that associates with this is that in the original solution
 where the parser task puts commands to COM2 input server, the engineer
 task is unaware of when these bytes are actually put into the buffer.
 The commandWorker is introduced to resolve these issues.
\end_layout

\begin_layout Standard
On start, the engineer creates a commandWorker.
 The commandWorker then immedietly becomes receive blocked on the engineer.
 When the engineer receives a command from the parser, the engineer puts
 the command into it's command buffer.
 The command worker would then be taken off the send queue by an Reply()
 call with the first command on the command queue.
\end_layout

\begin_layout Standard
The execution of the 
\family typewriter
tr
\family default
 and 
\family typewriter
rv
\family default
 command is carried out by the commandWorker.
 Setting the speed is straight forward, where the worker simply print two
 bytes, indicating the desired speed and the train number.
 For reverse, 300 ticks of delay is inserted between setting the train to
 speed 0 and setting reverse, and a delay of 15 ticks is inserted between
 the reverse command and the setting of previous speed.
\end_layout

\begin_layout Standard
After each set speed or set reverse command, the commandWorker calls Send()
 to the engineer, letting it know that the certain action has been carried
 out.
 For an 
\family typewriter
rv
\family default
 call, the command worker receives three notifications: SetSpeed (0), SetReverse
, and SetSpeed (original speed).
 In this way, the engineer is able to garauntee to have the correct internal
 state when various commands are executed.
\end_layout

\begin_layout Subsubsection
X Marks The Spot
\end_layout

\begin_layout Standard
For the train has to be able to stop at arbitrarily far from a sensor position,
 the engineer receives a 
\begin_inset Quotes eld
\end_inset

X Marks The Spot
\begin_inset Quotes erd
\end_inset

 command from the parser.
 The user inputs 
\begin_inset Quotes eld
\end_inset

x [node index] [offset]
\begin_inset Quotes erd
\end_inset

 from the terminal, and the parser task would Send() to the engineer task.
 On receiving the message, the track node is retrieved using the track index.
 In subsequent update_location messages, the displacement between the current
 landmark and the target landmark is checked, with the offset taken into
 consideration.
 If the distance is smaller or equal to the stopping distance of the current
 speed, the stop command is issued.
\end_layout

\begin_layout Subsection
Path Finding
\end_layout

\begin_layout Standard
Pathfinding is done by the engineer in two parts.
 
\end_layout

\begin_layout Enumerate
First, the engineer finds the set of paths he should take, and converts
 that to enstructions, which is engineer movement instructructions to be
 followed.
 
\end_layout

\begin_layout Enumerate
Second, the engineer follows this and makes reservation as needed.
 The second part is in Path Following section.
\end_layout

\begin_layout Subsubsection
Plan Route
\end_layout

\begin_layout Standard
Plan route does the heavy lifting.
 
\end_layout

\begin_layout LyX-Code
/** 
\end_layout

\begin_layout LyX-Code
Returns -1 if no path exists, otherwise the length of the path.
 
\end_layout

\begin_layout LyX-Code
*/ 
\end_layout

\begin_layout LyX-Code
int planRoute(track_node *start, track_node *end, PathBuffer *pb);
\end_layout

\begin_layout Subsubsection
Priority queue min heap
\end_layout

\begin_layout Standard
The plan route requires a priority queue.
 This is created by a compiler macro, in heap.h.
 This heap contains pointers of PathNodes, which is an internal representation
 of what a path consists of.
 The queue size is defined by a compiler constant EXPLORE_SIZE, which is
 set to 8kb.
 This is enough to do reverse sided short moves pathing.
\end_layout

\begin_layout Subsubsection
PathNode
\end_layout

\begin_layout Standard
At any time in the PQ, it only contains the horizon PathNode.
 The PathNode with the minimum pathcost is popped from the PQ, and is followed
 for one more node, and pushed back onto the PQ.
 If the node followed was a branch, two child PathNode are created, one
 for each possible direction.
 Otherwise PathNode is created for the next track_node.
\end_layout

\begin_layout Standard
Eventually popped PathNode would have its track_node equal to the destination,
 and in this case the path is found to destination.
 We have guarantee this is the min cost path because it was the first popped
 out that had the destination.
\end_layout

\begin_layout Subsubsection
PathBuffer
\end_layout

\begin_layout Standard
A 
\series bold
pathbuffer
\series default
 is the communication container between the engineer and the pathfinding.
\end_layout

\begin_layout LyX-Code
/** 
\end_layout

\begin_layout LyX-Code
PathBuffer for passing around paths.
 
\end_layout

\begin_layout LyX-Code
Array of track_node indecies, ordered from destination 
\end_layout

\begin_layout LyX-Code
(0) to source (length).
 
\end_layout

\begin_layout LyX-Code
*/ 
\end_layout

\begin_layout LyX-Code
typedef struct PathBuffer {     
\end_layout

\begin_deeper
\begin_layout LyX-Code
int train_num;   /* Engineer: train_number for reservation planning */ 
    
\end_layout

\begin_layout LyX-Code
int length;     
\end_layout

\begin_layout LyX-Code
track_node *tracknodes[MAX_PATH_LENGTH];     
\end_layout

\begin_layout LyX-Code
bool reverse[MAX_PATH_LENGTH]; 
\end_layout

\end_deeper
\begin_layout LyX-Code
} PathBuffer;
\end_layout

\begin_layout Standard
The path is re-constructed, by following the parent pointer for PathNode
 until we find the start.
 In other words, we have found a path to dest, accessible via end.
 We reconstruct the path from end to start, filling in PathBuffer.
\end_layout

\begin_layout Subsubsection
Reverse (short) moves
\end_layout

\begin_layout Standard
Exit nodes do not lead anywhere.
 We have reverse move planning but following them is bit more difficult
 and not done.
 We will also not consider the reverse direction from an exit node.
 
\end_layout

\begin_layout Subsubsection
Track ownership
\end_layout

\begin_layout Standard
Upon reaching a node that is not owned by current train, it means another
 train has reserved this.
 The path is dropped from the priority queue, and not considered.
 In the worst case, all paths to destination is blocked, and plan route
 fails to find a route, returning error (-1).
\end_layout

\begin_layout Paragraph
Expanded Path
\end_layout

\begin_layout Standard
This is only useful when factoring in short moves.
 When there are short moves with reversing directions, it might be the case
 we need more space to manuver the train around, especially around branches/merg
es.
\end_layout

\begin_layout LyX-Code
/** 
\end_layout

\begin_layout LyX-Code
Returns an expanded version of the path, so the engineer can make
\end_layout

\begin_layout LyX-Code
reservations.
 Some reversing paths are too short and need more reservations.
\end_layout

\begin_layout LyX-Code
E.g.
 (path1) C12 -> MR14 <- MR11 -> C13 ->.
 
\end_layout

\begin_layout LyX-Code
The reversing at MR14 actually requires reservation of A3/A4 sensor track_node
\end_layout

\begin_layout LyX-Code
because the distance from MR14 to A3 is just 6 cm (shorter than a train's
\end_layout

\begin_layout LyX-Code
length).
 So path1 is expanded to (path2): [
\end_layout

\begin_layout LyX-Code
C12,43] ->  [MR14,107] ->  [A4,3] <-  [MR11,101] ->  [C13,44] ->.
 
\end_layout

\begin_layout LyX-Code
*/ 
\end_layout

\begin_layout LyX-Code
int expandPath(PathBuffer *pb);
\end_layout

\begin_layout Standard
By estimate, a train is approximately 20cm long.
 Factoring in that we are not very accurate in estimating short move distances,
 we should reserve the next two train-lengths from any track node we do
 a reverse on.
 Then iterate through the train nodes (in the copied PathBuffer): If there
 is a reverse on the tracknode, make sure to keep reserving track_nodes
 until padding is used up.
 Otherwise just copy back the original tracknode.
\end_layout

\begin_layout Subsubsection
Make Book
\end_layout

\begin_layout Standard
An engineer might need to make a series of reverses.
 This is handled by putting all the Enstructions into a book.
\end_layout

\begin_layout LyX-Code
/** 
\end_layout

\begin_layout LyX-Code
Takes a path buffer and converts it into a Ebook, which is a series of 
\end_layout

\begin_layout LyX-Code
engineer instructions (enstructions).
 Returns the number of enstructions, 
\end_layout

\begin_layout LyX-Code
0 to MAX_EBOOK_LENGTH.
 Or -1 on error.
 
\end_layout

\begin_layout LyX-Code
E.g.
 path2 [C12,43] ->  [MR14,107] ->  [A4,3] <-  [MR11,101] ->  [C13,44] ->
\end_layout

\begin_layout LyX-Code
creates the following enstructions: 
\end_layout

\begin_layout LyX-Code
1/ Togo MR14.
 Switch false.
 
\end_layout

\begin_layout LyX-Code
2/ Togo C13.
 Switch false.
 
\end_layout

\begin_layout LyX-Code
*/ 
\end_layout

\begin_layout LyX-Code
int makeEbook(PathBuffer *pb, Ebook *book);
\end_layout

\begin_layout Subsection
Path Following
\end_layout

\begin_layout Standard
An engineer needs to follow a path.
 A command to test this is to use the go command.
 The user specifies a desired node to go and which train number.
 
\end_layout

\begin_layout Standard
There are a few important containers which the information is passed around
 from path finding to the engineer.
 These are the containers.
\end_layout

\begin_layout LyX-Code
/** 
\end_layout

\begin_layout LyX-Code
Position for XMarksTheSpot stopping.
 
\end_layout

\begin_layout LyX-Code
*/ 
\end_layout

\begin_layout LyX-Code
typedef struct position {     
\end_layout

\begin_deeper
\begin_layout LyX-Code
track_node *node;     
\end_layout

\begin_layout LyX-Code
int offset; 
\end_layout

\end_deeper
\begin_layout LyX-Code
} Position;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
#define MAX_PATH_LENGTH (TRACK_MAX)// very generous
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/** 
\end_layout

\begin_layout LyX-Code
Turnout operation.
 The idea is that the engineer follows a series of these.
 
\end_layout

\begin_layout LyX-Code
Set to 0 if we should disregard this.
 Otherwise it is the logical OR of:
\end_layout

\begin_layout LyX-Code
(switch_number << 1) | (1 bit curved) 
\end_layout

\begin_layout LyX-Code
Note: use the getter.
 
\end_layout

\begin_layout LyX-Code
*/ 
\end_layout

\begin_layout LyX-Code
typedef int Turnop;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/** 
\end_layout

\begin_layout LyX-Code
Enstruction to pass to the engineer, in a sequential manner of exactly where
 
\end_layout

\begin_layout LyX-Code
he should goto and what track nodes he should reserve.
 
\end_layout

\begin_layout LyX-Code
*/ 
\end_layout

\begin_layout LyX-Code
typedef struct {     
\end_layout

\begin_deeper
\begin_layout LyX-Code
int id;     
\end_layout

\begin_layout LyX-Code
int length;     
\end_layout

\begin_layout LyX-Code
Position togo;      /* because goto is a reserved keyword */     
\end_layout

\begin_layout LyX-Code
Turnop turnops[MAX_PATH_LENGTH];     
\end_layout

\begin_layout LyX-Code
track_node *tracknodes[MAX_PATH_LENGTH]; 
\end_layout

\end_deeper
\begin_layout LyX-Code
} Enstruction;
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
/** 
\end_layout

\begin_layout LyX-Code
Ebook is a list of enstructions.
 Size 
\end_layout

\begin_layout LyX-Code
*/ 
\end_layout

\begin_layout LyX-Code
#define MAX_EBOOK_LENGTH  (MAX_PATH_LENGTH / 10) 
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
typedef struct ebook {     
\end_layout

\begin_deeper
\begin_layout LyX-Code
Enstruction enstructs[MAX_EBOOK_LENGTH];     
\end_layout

\begin_layout LyX-Code
int length; 
\end_layout

\end_deeper
\begin_layout LyX-Code
} Ebook; 
\end_layout

\begin_layout Standard
The go command tells the engineer to navigate to a certain location.
 To accomplish this, the engineer needs a path.
 Engineer asks for a path from where the engineer is currently at, to the
 go node.
 
\end_layout

\begin_layout Standard
The engineer handles a sequence of instructions.
 An 
\series bold
enstruction
\series default
 represents a single destination target, containing a list of track nodes
 that the engineer may need to reserve while enroute to the destination.
 And if the track node is a branch, there is information on which direction
 the branch should be switched to.
 
\end_layout

\begin_layout Standard

\series bold
Ebook
\series default
 contains a few enstructions.
 A sequence of short moves may consist of a series of enstructions, which
 at the end of each enstruction, two cases may exist: either (1) we reached
 the destination, or (2) if this isn't the case, then reverse command is
 required.
\end_layout

\begin_layout Standard
Here is how the engineer reads his ebook:
\end_layout

\begin_layout Itemize
When the ebook's length > 0, it is considered valid.
\end_layout

\begin_layout Itemize
Engineer always keeps his finger on which landmark he travel past.
\end_layout

\begin_layout Itemize
He leverages the existing X-marks-the-spot command and uses that to stop
 on his landmark.
 
\end_layout

\begin_layout Itemize
His only new responsibility is to correctly switch any turnouts that is
 on his path.
\end_layout

\begin_layout Subsection
Reservation
\end_layout

\begin_layout Section
Calibration
\end_layout

\begin_layout Standard
Two kinds of data are needed in order to achieve the goal of stopping at
 a given landmark on the track: the constant velocity and the stopping distance.
 
\end_layout

\begin_layout Subsection
Constant Velocity
\end_layout

\begin_layout Standard
A two dimensional array is declared in the engineer task to store time differenc
es between any two sensors: int timeDeltas[NUM_SENSORS][NUM_SENSOR];
\end_layout

\begin_layout Standard
Constant velocity is calibrated by populating the timeDeltas table described
 above.
 The actual data recorded in the two-dimensional table, with the two indices
 being sensor node indices, are time difference between the two sensors.
 The table is updated upon hitting a new sensor in a feedback loop fashion
 for accurate train velocity estimation 
\begin_inset Formula $v_{1}=(1-\alpha)v_{0}+\alpha v'$
\end_inset

 where 
\begin_inset Formula $\alpha$
\end_inset

 is the learning rate.
 We have 
\begin_inset Formula $\alpha=85\%$
\end_inset

.
\end_layout

\begin_layout Subsection
Stopping Distance
\end_layout

\begin_layout Standard
The stopping distance of of the train is manually measured, with the help
 of our calibration command, which issues stopping command when a particular
 sensor is measured.
 The stopping distance is then measured by measuring the distance between
 the head of the train and the sensor.
 There is one stopping distance for each train speed of a particular calibrated
 train.
\end_layout

\begin_layout Standard
Currently the data for stopping distances, which is an arrays of size 15,
 is stored within the engineer task.
 This set of stopping distances, mapped to speed 0 to 14, is measured with
 the pick-up of the train in the front (defined as forward direction of
 the train).
 In the case that the train is running in the 
\begin_inset Quotes eld
\end_inset

backward
\begin_inset Quotes erd
\end_inset

 direction, which means that the pick up is at the end of the train, an
 additional offset of 105mm is added to the stopping distance.
\end_layout

\end_body
\end_document
